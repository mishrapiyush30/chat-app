# Real-Time Chat App

A production-grade real-time chat application built with React, TypeScript, Tailwind CSS, and Supabase.

## Live Demo

This application is deployed on Render.com: [https://chat-app-xlqu.onrender.com](https://chat-app-xlqu.onrender.com)

## Features

- 🔐 Email/password authentication with Supabase Auth
- 💬 Real-time messaging with Supabase Realtime
- 🗑️ Delete your own messages
- 📱 Responsive design with modern UI
- 🔒 Row-Level Security (RLS) for data protection
- ⚡ Built with Vite for fast development
- 🚀 CI/CD pipeline with GitHub Actions
- 🐳 Dockerized for consistent deployment
- 🔄 Health monitoring endpoint at /health

## Deployment

This application is containerized and deployed using the following:

1. **Docker image**: [mishrapiyush30/chat-app](https://hub.docker.com/r/mishrapiyush30/chat-app)
2. **CI/CD**: GitHub Actions automatically builds and pushes the Docker image on each push to main
3. **Hosting**: Deployed on Render.com as a web service at [https://chat-app-xlqu.onrender.com](https://chat-app-xlqu.onrender.com)
4. **Monitoring**: Health endpoint at `/health` monitored via UptimeRobot

### Deployment Challenges & Learnings

- Configuring environment variables in Dockerized applications requires careful handling
- For React apps served through Nginx, proper configuration for SPA routing is crucial
- Adding a health check endpoint simplifies monitoring and improves operational awareness
- Using Docker Hub as an intermediate registry makes deployment more reliable

## Tech Stack

- **Frontend Framework**: React 18 with TypeScript
- **Build Tool**: Vite
- **Styling**: Tailwind CSS with shadcn/ui components
- **Backend & Database**: Supabase (PostgreSQL)
- **Authentication**: Supabase Auth
- **Real-time Communication**: Supabase Realtime
- **Containerization**: Docker
- **CI/CD**: GitHub Actions
- **Hosting**: Render.com

## Prerequisites

- Node.js 18+ and npm
- Supabase account and project
- Docker and Docker Compose (for containerized deployment)

## Quick Start

1. **Clone and install dependencies:**
   ```bash
   git clone https://github.com/mishrapiyush30/chat-app.git
   cd chat-app
   npm install
   ```

2. **Set up Supabase:**
   - Create a new project at [supabase.com](https://supabase.com)
   - Copy your project URL and anon key
   - Create a `.env` file with your credentials (see Environment Variables section)

3. **Set up the database schema:**
   Run this SQL in your Supabase SQL Editor:
   ```sql
   -- Create messages table
   create table if not exists public.messages (
     id bigint generated by default as identity primary key,
     user_id uuid references auth.users on delete cascade not null,
     content text not null check (char_length(content) <= 500),
     inserted_at timestamptz default now()
   );

   -- Enable realtime
   alter publication supabase_realtime add table public.messages;

   -- Enable RLS
   alter table public.messages enable row level security;

   -- RLS Policies
   create policy "Users can insert their own messages"
     on public.messages for insert
     with check (auth.uid() = user_id);

   create policy "Users can view all messages"
     on public.messages for select
     using (true);

   create policy "Users can delete their own messages"
     on public.messages for delete
     using (auth.uid() = user_id);
   ```

4. **Start the development server:**
   ```bash
   npm run dev
   ```

5. **Open http://localhost:8080 and start chatting!**

## Docker Deployment

### Running Locally with Docker

```bash
# Build the Docker image
docker build -t chat-app .

# Run the container
docker run -p 8080:80 -e VITE_SUPABASE_URL=your_supabase_url -e VITE_SUPABASE_ANON_KEY=your_supabase_key chat-app
```

Access the application at http://localhost:8080

### Running with Docker Compose

```bash
# Create a .env file with your Supabase credentials
echo "SUPABASE_URL=your_supabase_url" > .env
echo "SUPABASE_ANON_KEY=your_supabase_anon_key" >> .env

# Start the container
docker-compose up -d

# Stop the container
docker-compose down
```

## Environment Variables

Create a `.env` file with:

```env
VITE_SUPABASE_URL=your_supabase_project_url
VITE_SUPABASE_ANON_KEY=your_supabase_anon_key
```

## CI/CD Pipeline

This project uses GitHub Actions for continuous integration and deployment:

1. **Build & Test Pipeline** (.github/workflows/docker-ci.yml)
   - Builds the Docker image
   - Runs tests (when configured)
   - (When enabled) Publishes the image to Docker Hub

2. **Deployment Pipeline** (.github/workflows/render-deploy.yml)
   - Triggers after successful build on main branch
   - Deploys the application to Render.com (when configured)

To enable Docker Hub publishing and deployment:
- Run `./setup-docker-hub.sh` to set up Docker Hub credentials
- Follow the instructions in [docs/DEPLOYMENT.md](docs/DEPLOYMENT.md)

GitHub Actions Workflow Status:
![Docker CI/CD Pipeline](https://github.com/[username]/chat-app/actions/workflows/docker-ci.yml/badge.svg)
![Deploy to Render](https://github.com/[username]/chat-app/actions/workflows/render-deploy.yml/badge.svg)

## Project Structure

```
chat-app/
├── public/             # Static assets
├── src/
│   ├── components/     # UI components
│   │   └── ui/         # shadcn/ui components
│   ├── contexts/       # React contexts
│   │   └── AuthContext.tsx
│   ├── hooks/          # Custom React hooks
│   ├── lib/            # Utility functions and services
│   │   └── supabaseClient.ts
│   ├── pages/          # Page components
│   └── App.tsx         # Main application component
├── .env                # Environment variables (create this)
├── Dockerfile          # Docker configuration
├── docker-compose.yml  # Docker Compose configuration
├── nginx.conf          # Nginx configuration for production
└── package.json        # Project dependencies
```

## Security Features

- Row-Level Security (RLS) policies ensure users can only delete their own messages
- All messages are visible to authenticated users
- JWT-based authentication with secure session management
- Environment variables for sensitive configuration

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Test thoroughly
5. Submit a pull request

## License

MIT License
